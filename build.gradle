import com.github.rjeschke.txtmark.*
import org.apache.tools.ant.filters.*

buildscript {
  apply from: "versions.gradle"
  
  repositories {
    mavenCentral()
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {

    classpath group: 'edu.holycross.shot', name : 'hocuspocus' , version: hocuspocusVersion 
    classpath group: 'edu.holycross.shot', name : 'prestochango' , version: prestochangoVersion
    classpath group: 'edu.holycross.shot', name : 'abracadabra' , version: abracadabraVersion
    classpath group: 'edu.holycross.shot', name : 'nysi' , version: nysiVersion
    classpath group: 'org.homermultitext', name : 'hmt-utils' , version: hmtutilsVersion

    classpath group: 'com.github.rjeschke', name: 'txtmark', version: '0.11'
    
  }
}




import org.homermultitext.utils.HmtTokenizer
import edu.harvard.chs.cite.CtsUrn
import edu.holycross.shot.hocuspocus.Corpus
import edu.holycross.shot.prestochango.CollectionArchive
import edu.holycross.shot.abracadabra.CiteIndex
import edu.holycross.shot.nysi.ImgTurtleizer

import org.apache.tools.ant.filters.*


// hmtarchive project
apply plugin: "base"
apply plugin:  "groovy"
apply plugin:  "maven"
apply from: "versions.gradle"


group = "org.homermultitext"

if (project.hasProperty("nightly")) {
    version = "${new Date().format('yyyy-MM-dd')}".toString()
} else {
    version = '2015.1'
}

if (project.hasProperty('conf')) {
    System.err.print "Using configuration data from ${conf}"
    File confFile = new File(conf)
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${conf} found.")
    } else {
        apply from: conf
    }

} else {
    File confFile = new File("conf.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${confFile} found.")
    } else {
        println "Using default configuration in 'conf.gradle'"
        apply from: "conf.gradle"
    }
}


if (project.hasProperty('pub')) {
    System.err.print "Using configuration data from ${pub}"
    File confFile = new File(pub)
    if (! confFile.exists()) {
        throw new Exception("No publication configuration file ${pub} found.")
    } else {
        apply from: pub
    }

} else {
    File confFile = new File("pub.gradle")
    if (! confFile.exists()) {
        throw new Exception("No publication configuration file ${confFile} found.")
    } else {
        println "Using default configuration in 'pub.gradle'"
        apply from: "pub.gradle"
    }
}




repositories {
    mavenCentral()
    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/groups/public/"
    }
    // useful while waiting for new releases of HMT dependencies to 
    // percolate through to public:
    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/repositories/releases/"
    }
}

configurations {
    hmtPublications
    kludgePub
}

dependencies {

  compile group: 'edu.holycross.shot', name : 'hocuspocus' , version: hocuspocusVersion
  compile group: 'edu.holycross.shot', name : 'prestochango' , version: prestochangoVersion
  compile group: 'edu.holycross.shot', name : 'abracadabra' , version: abracadabraVersion
  compile group: 'edu.holycross.shot', name : 'nysi' , version: nysiVersion
  compile group: 'org.homermultitext', name : 'hmt-utils' , version: hmtutilsVersion

  compile group: 'org.codehaus.groovy', name: 'groovy-all', version: groovyversion

  compile group: 'edu.harvard.chs', name : 'cite' , version: citeVersion
  compile group: 'edu.harvard.chs', name : 'greekutils' , version: greekutilsVersion

  compile group: 'com.thaiopensource', name:'jing', version: jingversion    
  compile group: 'net.sf.saxon', name: 'saxon-dom', version: saxonversion

  //testCompile group: 'junit', name: 'junit', version: junitversion
  testCompile group :'xmlunit', name: 'xmlunit', version: xmlunitversion

  // For concordion:
  testCompile 'junit:junit:4.11'
  testCompile 'org.concordion:concordion:1.4.4'
}



task setUpEditions(type: Copy) {
    description = "Generates README to accompany XML version of HMT editions."
    from (file("${editionsDir}")) {
        include 'README-editions.md'
        rename 'README-editions.md', 'README.md'
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/editions/archive"
}



///////////////////////////////////////////////////////////////////////////
//// Tasks for assembling Upsilon 1.1 editions from source material

task e3Readme (type: Copy) {
    description = ""
    from ("${editionsDir}/Esc-Upsilon-1-1") {
        include 'README.md'
    }
    into "${buildDir}/${compositeDir}/Esc-Upsilon-1-1"
}


task e3Iliad(type: JavaExec, dependsOn: [e3Readme, compileGroovy]) {
    description = "Compiles single Iliad text from multiple source files."
    main = "org.homermultitext.IliadCompiler"
    args = ["${editionsDir}/Esc-Upsilon-1-1/Iliad", "teiHeaders/Esc-Upsilon-1-1/Esc-Upsilon-1-1-Iliad.xml", "${buildDir}/${compositeDir}/Esc-Upsilon-1-1" ]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


task e3Header(type: Copy) {

    from ('teiHeaders/Esc-Upsilon-1-1')
    into "${buildDir}/headers/Esc-Upsilon-1-1"
    include ('Esc-Upsilon-1-1-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Main scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-e3.xml')
    }

}

task e3Scholia (type: JavaExec, dependsOn: [e3Header, e3Readme, compileGroovy]) {
    description = "test e3"
    main = "org.homermultitext.ScholiaCompiler"
    args = ["${editionsDir}/Esc-Upsilon-1-1/Scholia","${buildDir}/headers/Esc-Upsilon-1-1/Esc-Upsilon-1-1-Scholia-e3.xml", "${buildDir}/${compositeDir}/Esc-Upsilon-1-1" , "e3"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

task e3(dependsOn: [e3Scholia, e3Iliad]) {
    doLast {
        System.err.println "All Upsilon 1.1 texts validate syntactically."
    }
}

///////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////
//// Tasks for assembling Venetus A editions from source material

task venAReadme (type: Copy) {
    description = "Add README file for Venetus A archive to build area."
    from ("${editionsDir}/VenetusA") {
        include 'README.md'
    }
    into "${buildDir}/${compositeDir}/VenetusA"
}

// Texts other than Iliad and scholia
task venAOther (type: Copy, dependsOn: venAReadme) {
    description = "Copies into build area all texts other than Iliad and scholia"
    //    from ("${editionsDir}/VenetusA/OtherTexts")
    from ("${editionsDir}/${vaOther}")
    into("${buildDir}/editions/archive/VenetusA")
    include("*.xml")
    doLast {
      //        File srcDir = new File("${editionsDir}/VenetusA/OtherTexts")
      File srcDir = new File("${editionsDir}/${vaOther}")
        def xmlList =  srcDir.list([accept:{d, f-> f ==~ /.*xml/ }] as FilenameFilter
                    ).toList()
        File outDir = new File("${buildDir}/editions/archive/VenetusA")
        xmlList.each { fName ->
            File f = new File(outDir, fName)
            def root = new XmlParser().parse(f)
            System.err.println "${fName} validates syntactically"
        }
    }
}

// Iliad
task venAIliad(type: JavaExec, dependsOn: [venAReadme, compileGroovy]) {
    description = "Compiles single Iliad text from multiple source files."
    main = "org.homermultitext.IliadCompiler"
    //    args = ["${editionsDir}/VenetusA/Iliad", "teiHeaders/VenetusA/VenetusA-Iliad.xml", "${buildDir}/${compositeDir}/VenetusA" ]

    args = ["${editionsDir}/${vaIliad}", "teiHeaders/VenetusA/VenetusA-Iliad.xml", "${buildDir}/${compositeDir}/VenetusA" ]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

// Venetus A, main scholia
task msAHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A main scholia"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Main scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-msA.xml')
    }
}

task msAScholia(type: JavaExec, dependsOn: [msAHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A main scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //  args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msA.xml", "${buildDir}/${compositeDir}/VenetusA" , "msA"]
    args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msA.xml", "${buildDir}/${compositeDir}/VenetusA" , "msA"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

// Venetus A, intermarginal scholia
task msAimHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A intermarginal scholia"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Intermarginal scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-msAim.xml')
    }

}
task msAimScholia(type: JavaExec, dependsOn: [msAimHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A main scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAim.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAim"]
        args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAim.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAim"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


// Venetus A, interior scholia
task msAintHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A interior scholia"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Interior scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-msAint.xml')
    }
}
task msAintScholia (type: JavaExec, dependsOn: [msAintHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A interior scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAint.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAint"]
        args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAint.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAint"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime

}


// Venetus A, exterior scholia
task msAextHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A exterior scholia"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Exterior scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-msAext.xml')
    }
}
task msAextScholia(type: JavaExec, dependsOn: [msAextHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A exterior scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAext.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAext"]
    args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAext.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAext"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


// Venetus A, interlinear scholia
task msAilHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A interlinear scholia"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Interlinear scholia'] )
    rename { String fileName ->
        fileName.replace('.xml','-msAil.xml')
    }
}
task msAilScholia (type: JavaExec, dependsOn: [msAilHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A interlinear scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAil.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAil"]
    args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAil.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAil"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


// Venetus A, later scholia
task msALaterHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A scholia in later hand"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Scholia in later hand in main scholia block '] )
    rename { String fileName ->
        fileName.replace('.xml','-msALater.xml')
    }
}
task msALaterScholia (type: JavaExec, dependsOn: [msALaterHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A interlinear scholia"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msALater.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAlater"]
    args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msALater.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAlater"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


// Venetus A, later intermarginal scholia
task msAimLaterHeader(type: Copy) {
    description = "Compiles TEI header to reuse in composite edition of Ven A scholia in later hand in intermarginal position"
    from ('teiHeaders/VenetusA')
    into "${buildDir}/headers/VenetusA"
    include ('VenetusA-Scholia.xml')
    filter(ReplaceTokens, tokens : [scholiatitle : 'Scholia in later hand in intermarginal position '] )
    rename { String fileName ->
        fileName.replace('.xml','-msAimLater.xml')
    }
}
task msAimLaterScholia (type: JavaExec, dependsOn: [msAimLaterHeader, venAReadme, compileGroovy]) {
    description = "Compiles and validates complete edition of Venetus A later scholia in intermarginal position"
    main = "org.homermultitext.ScholiaCompiler"
    //    args = ["${editionsDir}/VenetusA/Scholia","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAimLater.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAimlater"]
    args = ["${editionsDir}/${vaScholia}","${buildDir}/headers/VenetusA/VenetusA-Scholia-msAimLater.xml", "${buildDir}/${compositeDir}/VenetusA" , "msAimlater"]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

///////////////////////////////////////////////////////////////////////////







task inv (type: Copy) {
    description = "Copies text inventory and README into build area."
    from ("${inventoriesDir}")
    into "${buildDir}/${compositeDir}"
    //    include ('onlineInventory.xml', 'README-HMT-archive.md', "*.rng")
    include (textInventory, 'README-HMT-archive.md', "*.rng")
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    rename { String fileName ->
        fileName.replace('-HMT-archive','')
    }

    rename { String fileName ->
        fileName.replace('onlineI','i')
    }

    rename { String fileName ->
      fileName.replace('test','')
    }
}

task translations (type: Copy) {
    description = "Copies translations of texts into build area."
    from ("${editionsDir}/translations")
    into "${buildDir}/${compositeDir}/translations"
}

task furmanEditions (type: Copy) {
    description = "Copies Furman-generated  editions of texts into build area."
    from ("${editionsDir}/Furman")
    into "${buildDir}/${compositeDir}/Furman"
}


task venetusA(type: VenetusATask, dependsOn: [inv, venAIliad, venAReadme, msAScholia, msAextScholia, msAilScholia, msAimLaterScholia, msAimScholia, msAintScholia, msALaterScholia, translations, venAOther])  {
    editionsArchive = file("${compositeDir}")
}

class VenetusATask extends DefaultTask {
  @OutputDirectory
  File editionsArchive

  @TaskAction
  def msg() {
    System.err.println "All venetusA texts validated syntactically."
  }
}

/// Can add dependencies on other MSS when we have tasks for them.
//task editions(type: Zip, dependsOn: [venetusA, e3, furmanEditions]) {
task editions(type: Zip, dependsOn: [venetusA]) {
    description="Builds zip file of all edited manuscripts."
    classifier = 'xml'
    baseName = "hmt-editions"
    from(file("${buildDir}/${compositeDir}"))
    include("**/*.xml", "**/README.md")
    doLast {
        System.err.println "All Venetus A texts validate syntactically, and are compiled in zip file hmtarchive-VERSION-editions.zip."
    }
}



///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//// Tasks for secondary processing of composite editions
//// INDEXING SCHOLIA TO TEXT:


task indexVenetusAScholia (type: JavaExec, dependsOn : "compileGroovy") {
    description="Generates tsv relating scholia to Iliad passage commented on."
    main = "org.homermultitext.ScholiaIndexer"

    args = [
      //"${editionsDir}/VenetusA/Scholia",
      "${editionsDir}/${vaScholia}",
      "${citeDir}/indices",
      "scholiaToIliad.tsv",
      "urn:cts:greekLit:tlg0012.tlg001.msA", 
      "hmt" 
    ]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}

indexVenetusAScholia.doLast {
  def argSet = [
    //  "${editionsDir}/VenetusA/Scholia",
      "${editionsDir}/${vaScholia}",
      "${citeDir}/indices",
      "scholiaToIliad.tsv",
      "urn:cts:greekLit:tlg0012.tlg001.msA", 
      "hmt"
      ]
  println "ARGS WERE: " + argSet
}

task indexE3Scholia (type: JavaExec, dependsOn : "compileGroovy") {
    description="Generates tsv relating scholia to Iliad passage commented on."
    main = "org.homermultitext.ScholiaIndexer"

    args = [
      "${editionsDir}/Esc-Upsilon-1-1/Scholia",
      "cite/indices",
      "scholiaToIliad-e3.tsv",
      "urn:cts:greekLit:tlg0012.tlg001.e3", 
      "hmt" 
    ]

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


task tabE3 (type: JavaExec, dependsOn : ["compileGroovy", "e3", "inv"]) {
    description = "Uses a hocuspocus tabulator to create tabular files for all editions"
    main = "org.homermultitext.HmtTabulator"
    args = ["${buildDir}/${compositeDir}", "${buildDir}/${compositeDir}/inventory.xml",  "${buildDir}/tabulated"]	

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}



///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//// Tasks for secondary processing of composite editions
//// TABULATION:

//task tabFiles (dependsOn : ["compileGroovy", "editions"]) {
task tabFiles() {
  description = "Generates a tabular representation of all texts in configured text archive."
}
tabFiles.doLast() {
    File inv = new File("${buildDir}/${compositeDir}/inventory.xml")
  File archiveDir = new File("${buildDir}/${compositeDir}")
File schemaFile = new File("${buildDir}/${compositeDir}/TextInventory.rng")

  Corpus c = new Corpus(inv,archiveDir, schemaFile)
  c.tabulateRepository(new File(buildDir, "tabulated"))
}
/*

    description = "Uses a hocuspocus tabulator to create tabular files for all editions"
    main = "org.homermultitext.HmtTabulator"
    args = ["${buildDir}/${compositeDir}", "${buildDir}/${compositeDir}/inventory.xml",  "${buildDir}/tabulated"]	

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}
*/

task setupTabs (type: Copy) {
    description = "Generates README to accompany tabulated versions of HMT editions."
    from ("${editionsDir}") {
        include 'README-tabulated.md'
        rename 'README-tabulated.md', '1-README.md'
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/tabulated"
}

task tabulated(type: Zip, dependsOn: [tabFiles, setupTabs]) {
    description = "Creates zip package of all HMT editions in tabular format."
    classifier = 'tabulated'
    from (file("${buildDir}/tabulated"))
    include("**/*.txt", "**/*.md")
    baseName = "hmt-editions"
    doLast {
        System.err.println "Tabulated version of all XML editions compiled in zip file hmt-editions-tabulated"
    }

}

///////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////
//// Tasks for secondary processing of composite editions


// SHOULD BE PUT BACK IN HMTARCHIVE!  CITEMGR CAN ONLY DO GENERIC
// THINGS AND ALL TOKENIZATIONS ARE SPECIFIC TO CLASSIFICATION SCHEME



task setupTokens (type: Copy) {
    description = "Generates README to accompany tokenization data from HMT editions."
    from ("${editionsDir}") {
        include 'README-tokens.md'
        rename 'README-tokens.md', 'README.md'
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/tokens"
}

task tokensttl(type: JavaExec, dependsOn: [compileGroovy, setupTokens, editions]) {
    description = "Tokenizes tabular editions and generates RDF statements for each token"
    main = "org.homermultitext.HmtTokenizer"
    args = ["${buildDir}/${compositeDir}", "${buildDir}/${compositeDir}/inventory.xml",  "${buildDir}/tokens"]	

    classpath sourceSets.main.output.classesDir
    classpath configurations.runtime
}


task tokens(type: Zip, dependsOn: tokensttl) {
    description = "Packages tokenization TTL"
    from (file("${buildDir}/tokens"))
    baseName = "hmt-tokens"
    doLast {
        System.err.println "Full text of all editions tokenized, described in RDF TTL, and compiled in zip file hmt-editions-tokens"
    }
}

task tokenize(dependsOn: [tabFiles]) {
  description = "Tokenizes previously tabulated texts."
}

tokenize.doLast{
  File tabsDir = new File("${buildDir}/tabulated")
  File outputFile = new File(buildDir,"tokens.txt")
  String separatorStr = "#"
  HmtTokenizer tokenizer = new HmtTokenizer(tabsDir, outputFile, separatorStr)
  //tokenizer.debug = 5
  tokenizer.tokenizeTabs()
}


///////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////
//// TASKS PUBLISHING CITE ARCHIVES

task setUpCollections (type: Copy) {
    description = "Prepares files for publishing collections archive."
    from ('cite/collections') {
      include ('README.md', 'inventory/hmtcollections.xml', '**/*.csv', '**/*.tsv')
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/collections"
}

task compileScholiaCollection() {
  description = "Creates composite scholia collection form multiple source files"
}

compileScholiaCollection.doLast {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File outputDir = new File(buildDir, "collections")
  if (! outputDir.exists()) {
    outputDir.mkdir()
  }
  File outFile = new File(outputDir, "scholiaInventory.csv")
  outFile.setText("CtsUrn,Comments,VisualEvidence,FolioUrn\n")
  
  File srcDir = new File("cite/scholiaInventory")

  srcDir.eachFileMatch(~/.*.csv/) { csv ->  
    Integer lineCount = 0
    csv.eachLine { ln ->
      if (lineCount > 0) {
	String cts = ln.replaceFirst(/,.+/, '')
	String noCts = ln.replaceFirst(/^[^,]+,/,'') 
	CtsUrn urn
	try {
	  urn = new CtsUrn(cts.replaceAll(/["]/,''))
        } catch (Exception e) {
          System.err.println "Exception in scholia inventory for line " + ln
          throw e
        }
	String psg = urn.getRef().replaceAll(/[.]/,"_")
	String citeStr = "urn:cite:hmt:scholia.${urn.getWork()}_${psg}"
        outFile.append "${citeStr},${urn},${noCts}\n"
      }
      lineCount++;
    }
  }
}

task collections(type: Zip, dependsOn: [setUpCollections, compileScholiaCollection]) {
    description = "Creates zip package of all HMT collections archive."
    from (file("${buildDir}/collections"))
    baseName = "hmt-collections"

}

task setUpImages (type: Copy) {
    description = "Prepares files for publishing HMT Image archive."
    from ('cite/images') {
        include ('README.md', '**/*.csv', '**/*.tsv')
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString()] )
    into "${buildDir}/images"
}

task images(type: Zip, dependsOn: [setUpImages]) {
    description = "Creates zip package of HMT image archive."
    from (file("${buildDir}/images"))
    baseName = "hmt-images"
}

task setUpIndices (type: Copy) {
    description = "Prepares files for publishing CITE Index archive."
    from ('cite/indices') {
      include ('README.md', 'inventory/hmtindices.xml', '**/*.csv', '**/*.tsv')
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString()] )
    into "${buildDir}/indices"
}

task indices(type: Zip, dependsOn: [setUpIndices]) {
    description = "Creates zip package of all HMT CITE Indices."
    from (file("${buildDir}/indices"))
    baseName = "hmt-indices"

}

task cite (dependsOn : [editions, collections, indices, images]) {
    doLast {
        println "Built zip files of all HMT CITE archives."
    }
}

///////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////
//// RDF TASKS 

//task ctsttl(dependsOn: editions) {
task ctsttl(dependsOn: editions) {
  description = "Use hocuspocus to create a full rdf representation of the text archive suitable for import into a CTS"
}
ctsttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File inv = new File("${buildDir}/${compositeDir}/inventory.xml")
  File archiveDir = new File("${buildDir}/${compositeDir}")
File schemaFile = new File("${buildDir}/${compositeDir}/TextInventory.rng")
  Corpus c = new Corpus(inv,archiveDir, schemaFile)
c.debug = 10




  File ttlDir = new File(buildDir, "rdf")
  if (! ttlDir.exists()) {
    ttlDir.mkdir()
  }
  File ttlFile = new File(ttlDir,"cts.ttl")
  c.ttl(ttlFile, prefix, ttlDir)
}


task copyImgs (type: Copy) {
  description = "Filter copies configurable image collection info."
  from (file("cite/images/collections")) {
    include '*.csv'
  }
  filter(ReplaceTokens, tokens : [pyramids : pyramids] )
  into "${buildDir}/images"
}

task imgttl (dependsOn: [copyImgs]) {
  description = "Generates RDF for configured image repository"
}
imgttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File rdfDir = new File("${buildDir}/rdf")
  if (! rdfDir.exists()) {
    rdfDir.mkdir()
  }
  File ttlFile = new File(rdfDir,"citeimgs.ttl")
  ImgTurtleizer imgttl = new ImgTurtleizer("${buildDir}/images")
  imgttl.ttl(ttlFile, prefix)
}

task ccttl() {
  description = "Generates RDF for Collections configured for prestochango"
}
ccttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File schemaFile = new File("schemas/cite/CiteCollectionInventory.rng")

  File invFile = new File("cite/collections/inventory/hmtcollections.xml")
  File archiveDir = new File("cite/collections")
  CollectionArchive cc = new CollectionArchive(invFile, schemaFile, archiveDir)

  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File ttlDir = new File(buildDir, "rdf")
  if (! ttlDir.exists()) {
    ttlDir.mkdir()
  }
  File testOut = new File(ttlDir, "collections.ttl")
  cc.ttl(testOut, prefix)
}


task idxttl() {
  description = "Generates RDF for indices configured for abracadabra"
}
idxttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File inv = new File("cite/indices/inventory/hmtindices.xml")
  File idxDir = new File("cite/indices")

println "Make CiteIndex from ${inv} and ${idxDir}"
  CiteIndex idx = new CiteIndex(inv, idxDir)
idx.debug = 10
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File ttlDir = new File(buildDir, "rdf")
  if (! ttlDir.exists()) {
    ttlDir.mkdir()
  }
  File outFile = new  File (ttlDir,"indices.ttl")
  idx.ttl(outFile, prefix)

  // manually add indexing of scholia until this is added
  // to CITE Collections...

}


task setUpTurtle(type: Copy) {
    description = "Generates README to accompany RDF version of HMT editions."
    from (file("${editionsDir}")) {
        include 'README-rdf.md'
        rename 'README-rdf.md', 'README.md'
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/rdf"
}

task allTtl( dependsOn: [ctsttl, imgttl, ccttl, idxttl, setUpTurtle]) {
  description = "Generates TTL for entire HMT archive."
  doLast {
    String charEnc = "UTF-8"

        
    File ctsttl = new File("${buildDir}/rdf/cts.ttl")
    File collectionsttl = new File("${buildDir}/rdf/collections.ttl")
    File idxttl = new File("${buildDir}/rdf/indices.ttl")
    File citeimgttl = new File("${buildDir}/rdf/citeimgs.ttl")

    File ttl = new File("${buildDir}/rdf/all.ttl")        
    ttl.append(ttlPrefix)

    def srcFiles =  [ctsttl, collectionsttl, idxttl, citeimgttl]
    srcFiles.each {  f ->
      if (f.exists()) {
	ttl.withWriterAppend(charEnc) {writer -> 
	  f.newReader(charEnc).eachLine { String line -> 
	    writer << "\n${line}"         
	  } 
	}
      } 
    }

    System.out.println "\nCompleted generating all TTL in ${buildDir}/ttl.\n"
  }
}

task rdf(type: Zip,dependsOn: allTtl) {
    description = "Creates zip package of entire HMT archive in TTL format."
    from (file("${buildDir}/rdf"))
    include("**/*.ttl", "README.md")
    baseName = "hmt-rdf"
    doLast {
        System.err.println "RDF (TTL) version of the entire HMT archive compiled in zip file hmt-rdf"
    }
}

task zipKludge(type: Zip) {
    description = "Creates zip package of kludged manual set up"
    from (file("kludge"))
    baseName = "hmt-rdf"
}

task labelPublication(type: Copy) {
    description = "Generates README to accompany packages for distribution."
    from (file("${rootDir}")) {
        include 'README-version-guide.md'
    }
    filter(ReplaceTokens, tokens : [packagedate : "${new Date().format('yyyy-MM-dd')}".toString(), versionid : version] )
    into "${buildDir}/distributions"

}

labelPublication.doFirst {
  println "Version is ${version}"
}


///////////////////////////////////////////////////////////////////////////

artifacts {

  kludgePub zipKludge

  hmtPublications collections


  hmtPublications images

  hmtPublications indices  

  hmtPublications editions

  hmtPublications tabulated

//  hmtPublications rdf


//  hmtPublications tokens


}


uploadArchives {
    repositories.mavenDeployer {
        repository(url: nexusRepo) {                   
            authentication (userName: nexusUser, password: nexusPassword)
        }
    }
}

uploadKludgePub {
    repositories.mavenDeployer {
        repository(url: nexusRepo) {                   
            authentication (userName: nexusUser, password: nexusPassword)
        }
    }
}


uploadHmtPublications {
    repositories.mavenDeployer {
        repository(url: nexusRepo) {                   
            authentication (userName: nexusUser, password: nexusPassword)
        }
    }
    doLast {
        System.err.println "All HMT publications uploaded."
    }
}


// Always buildArchives from a completely clean state
//buildArchives.dependsOn clean


// HmtPublications are build from scratch, and get
// a labelling text file to boot:
buildHmtPublications.dependsOn labelPublication












// for specs with concordion:
sourceSets {
    main {
        java {
            srcDir 'src'
        }
        resources {
            srcDir 'src'
        }
    }
    test {
        java {
	  srcDir "specs/java"
        }
        resources {
	  srcDir "${buildDir}/specs"
        }
    }
}

task cpResources(type: Copy) {
  from "specs/resources"
  into "${buildDir}/specs"
}

task setUpResources(dependsOn: cpResources) {
}
setUpResources.doLast {
  println "READING FILE TREE FROM " + mdSrc + " DIRECTORY"
  FileTree tree = fileTree(mdSrc) {
    include "**/*.md"
  }
  tree.visit { f ->
    if (f.relativePath.isFile()) {
      File inFile = new File("${mdSrc}/${f.relativePath}")
      println "Need to work on " + inFile
      def segs = f.relativePath.getSegments()
      String treePath = "${buildDir}/specs"
      Integer limit =  segs.size() - 1
      segs.eachWithIndex { s, i ->
	if (i < limit) {
	  treePath = "${treePath}/${s}"
	  File nxtDir = new File(treePath)
	  if (! nxtDir.exists()) {
	    nxtDir.mkdir()
	  }
	}
      }
      File outDir = new File(treePath)
      String htmlFileName = f.relativePath.getLastName().replaceFirst(/.md$/,".html")
      File htmlFile = new File(outDir, htmlFileName)
      println "Created ${htmlFile}"

      String body = Processor.process(inFile.getText("UTF-8"),Configuration.DEFAULT)
      htmlFile.setText("${htmlPreface}${body}${htmlEnd}", "UTF-8")
    }
  }
}


test.dependsOn setUpResources
test {
    systemProperties 'concordion.output.dir': file("${buildDir}/concordion-results")
}

task addVersion(){
}
addVersion.doLast {
  tokenMap["version"] = version
  tokenMap["deps"] = """
    <tr><td>cite</td><td>${citeVersion}</td></tr>
    <tr><td>hocuspocus</td><td>${hocuspocusVersion}</td></tr>
    <tr><td>prestochango</td><td>${prestochangoVersion}</td></tr>
    <tr><td>abracadabra</td><td>${abracadabraVersion}</td></tr>
    <tr><td>nysi</td><td>${nysiVersion}</td></tr>
    <tr><td>hmt-utils</td><td>$hmtutilsVersion}</td></tr>
    <tr><td>greekutils</td><td>${greekutilsVersion}</td></tr>""".toString() 
}

task conc(type: Copy, dependsOn: [test, addVersion]) {
//task conc(type: Copy) {
  from "${buildDir}/concordion-results"
  into "${buildDir}/concordion-formatted"
  filter(ReplaceTokens, tokens: tokenMap)
}
