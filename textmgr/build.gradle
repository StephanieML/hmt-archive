import com.github.rjeschke.txtmark.*

buildscript {
  repositories {
    mavenCentral()
    maven {
      url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
  }
  dependencies {
    classpath group: 'com.github.rjeschke', name: 'txtmark', version: '0.11'

    // dependencies from versionMap:
    classpath group: 'edu.holycross.shot', name : 'hocuspocus' , version: versionMap['hocuspocus']
    classpath group: 'edu.holycross.shot', name : 'prestochango' , version: versionMap['prestochango']
    classpath group: 'edu.holycross.shot', name : 'abracadabra' , version: versionMap['abracadabra']
    classpath group: 'edu.holycross.shot', name : 'nysi' , version: versionMap['nysi']
    classpath group:       'org.homermultitext', name : 'hmt-utils', version: versionMap['hmtutils']
  }
}

import edu.holycross.shot.hocuspocus.Corpus

/*
import edu.holycross.shot.prestochango.CollectionArchive
import edu.holycross.shot.abracadabra.CiteIndex
import edu.holycross.shot.nysi.ImgTurtleizer
*/

//import org.apache.tools.ant.filters.*

apply plugin: "base"



// settings for core: build:  allow dynamic override
/*
if (hasProperty('proj')) {
    System.err.println "Using project configuration data from ${proj}"
    File confFile =  new File("${project.rootDir}/${proj}")
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${confFile} found.")
    }
    apply from: "${project.rootDir}/${proj}"

} else {
    File confFile = new File("${project.rootDir}/projects/projconf.gradle")
    if (! confFile.exists()) {
        throw new Exception("No configuration file ${confFile} found.")
    }
    println "Using default configuration in 'projconf.gradle'"
    apply from: "${project.rootDir}/projects/projconf.gradle"
}
*/





/* Settings for Digital Scholarly Edition data */
/*
if (hasProperty('dse')) {
    apply from: dse
}
*/
repositories {
    mavenCentral()
    
    maven {
        url "http://beta.hpcc.uh.edu/nexus/content/groups/public"
    }
    maven {
      url "https://oss.sonatype.org"
    }
}

/*
configurations {
  rdf
}

dependencies {
  rdf project(':core')
}

*/



task ctstab(dependsOn: ":ctsbldr:cts") {
  description = "Generates a tabular representation of all texts in configured text archive."
}
ctstab.doFirst() {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  File tabs = new File(buildDir, "tabs")
  if (! tabs.exists()) {
    tabs.mkdir()
  }
  println "Beginning to tabulate texts..."
}
ctstab.doLast() {
  File inv =  new File("${rootProject.rootDir}/ctsbldr/build/editions/archive/inventory.xml")
  File textArchive = new File("${rootProject.rootDir}/ctsbldr/build/editions/archive")
  File schema = new File("${rootProject.rootDir}/schemas/cts/Textinventory.rng")

  Corpus c = new Corpus(inv, textArchive, schema)
  c.tabulateRepository(new File(buildDir, "tabs"))
}



/*
task ctsttl() {
  description = "Generates TTL statements about text contents"
}
ctsttl.doFirst {
  System.err.println "ctsttl will use inventory ${ctsinventory}"
  System.err.println "and archive ${ctsarchive}"


}
ctsttl.doLast {
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }

  File inv
  File archiveDir

  if ((ctsinventory != "") && (ctsarchive != "")) {
    try {
      inv = new File("${ctsinventory}")
      archiveDir = new File("${ctsarchive}")
    } catch (Exception e) {
      System.err.println "ctsttl: unable to create inventory and archive!"
      throw e
    }
    Corpus c = new Corpus(inv,archiveDir, new File("${project.rootDir}/${textInvSchema}"))

    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File ttlFile = new File(ttlDir,"cts.ttl")
    c.ttl(ttlFile, prefix, ttlDir)
  }
}


task filterImgs(type: Copy) {
  description = "Filter copies configurable image collection info."
  from (file(imgcolldir)) {
    include '*.csv'
  }
  filter(ReplaceTokens, tokens : [pyramids : pyramids] )
  into "${buildDir}/images"
}
filterImgs.doFirst {
  println "Filter copy images in " + imgcolldir
}


task imgttl(dependsOn: [filterImgs]) {
  description = "Generates RDF for configured NYSI"
}
imgttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File rdfDir = new File("${buildDir}/ttl")
  if (! rdfDir.exists()) {
    rdfDir.mkdir()
  }
  File ttlFile = new File(rdfDir,"citeimgs.ttl")
   
  ImgTurtleizer imgttl = new ImgTurtleizer("${buildDir}/images")

  File imageDir = new File("${buildDir}/images")
  if (! buildDir.exists()) {
    buildDir.mkdir()
  }
  if (! imageDir.exists()) {
    imageDir.mkdir()
  }

  imgttl.ttl(ttlFile, prefix)
}




task ccttl {
  description = "Generates RDF for Collections configured for prestochango"
}
ccttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File schemaFile = new File("${project.rootDir}/${collectionInvSchema}")

  if ((collinv != "") && (collarchive != "")) {
	File invFile = new File(collinv)
	File archiveDir = new File(collarchive)
	CollectionArchive cc = new CollectionArchive(invFile, schemaFile, archiveDir)
	//cc.debug = 5
	println "\nFrom inventory in ${collinv} and data in ${collarchive}:"
	println "\tCollection list:  " + cc.getCollectionList() + "\n"
	if (! buildDir.exists()) {
	  buildDir.mkdir()
	}
	File ttlDir = new File(buildDir, "ttl")
	if (! ttlDir.exists()) {
	  ttlDir.mkdir()
	}
	File testOut = new File(ttlDir, "collections.ttl")
	cc.ttl(testOut, prefix)
  }
}


task idxttl () {
  description = "Generates RDF for indices configured for abracadabra"
}
idxttl.doLast {
  boolean prefix = project.hasProperty("prefix-all")

  File inv 
  File idxDir

  if ((idxinv != "") && (idxarchive != ""))   {
    try {
      inv = new File("${idxinv}")
      idxDir = new File("${idxarchive}")
    } catch (Exception e) {
      System.err.println "idxttl: unable to make index inventory and archive."
      throw e
    }
    CiteIndex idx = new CiteIndex(inv, idxDir)

    if (! buildDir.exists()) {
      buildDir.mkdir()
    }
    File ttlDir = new File(buildDir, "ttl")
    if (! ttlDir.exists()) {
      ttlDir.mkdir()
    }
    File outFile = new  File (ttlDir,"indices.ttl")
    idx.ttl(outFile, prefix)
  }
}


task ttl (dependsOn: [ctsttl, imgttl, ccttl, idxttl]) {
  description = "Concatenates separate TTL files into a single graph."
  doLast {
    String charEnc = "UTF-8"
    String prefix = "${prefixString}"

    File ctsttl = new File("${buildDir}/ttl/cts.ttl")
    File collectionsttl = new File("${buildDir}/ttl/collections.ttl")
    File idxttl = new File("${buildDir}/ttl/indices.ttl")
    File citeimgttl = new File("${buildDir}/ttl/citeimgs.ttl")

    def srcFiles =  [ctsttl, collectionsttl, idxttl, citeimgttl]

    File ttl = new File("${buildDir}/ttl/all.ttl")        
    ttl.append( prefix )

    srcFiles.each {  f ->
      if (f.exists()) {
	ttl.withWriterAppend(charEnc) {writer -> 
	  f.newReader(charEnc).eachLine {String line -> 
	    writer << "\n${line}"         
	  } 
	}
      } }
*/
// too slow to tolerate :-(
/*
        System.err.println "Adding data from cts ttl ..."
        ctsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }

        System.err.println "Adding data from collections ttl ..."
        collectionsttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }


        System.err.println "Adding data from index ttl ..."
        idxttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }



        System.err.println "Adding data from image ttl ..."
        citeimgttl.eachLine(charEnc) {
            ttl.append("${it}\n")
        }
*/

// Big project runs out of memory with this approach :-(
//+ ctsttl.getText(charEnc) + collectionsttl.getText(charEnc) + idxttl.getText(charEnc) + citeimgttl.getText(charEnc), charEnc)
/*

        System.out.println "\nCompleted generating all TTL in ${buildDir}/ttl.\n"
    }
}





task zipTtl(type: Zip, dependsOn: [ttl]) {
  description = "Builds a zip file of all TTL output"
  from(file("${buildDir}/ttl"))
  include("** / *.ttl")
}

artifacts {
  rdf zipTtl
}
*/

